"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_utils_1 = require("@datocms/cli-utils");
const cma_client_node_1 = require("@datocms/cli-utils/lib/cma-client-node");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const ts_node_1 = require("ts-node");
const find_nearest_file_1 = require("../../utils/find-nearest-file");
const MIGRATION_FILE_REGEXP = /^\d+.*\.(js|ts)$/;
class Command extends cli_utils_1.CmaClientCommand {
    async run() {
        var _a;
        this.requireDatoProfileConfig();
        const preference = (_a = this.datoProfileConfig) === null || _a === void 0 ? void 0 : _a.migrations;
        const { 'dry-run': dryRun, 'in-place': inPlace, source: sourceEnvId, destination: rawDestinationEnvId, } = this.parsedFlags;
        const migrationsDir = (0, path_1.resolve)(this.parsedFlags['migrations-dir'] ||
            (preference === null || preference === void 0 ? void 0 : preference.directory) ||
            './migrations');
        const migrationsModelApiKey = this.parsedFlags['migrations-model'] ||
            (preference === null || preference === void 0 ? void 0 : preference.modelApiKey) ||
            'schema_migration';
        try {
            await (0, promises_1.access)(migrationsDir);
        }
        catch {
            this.error(`Directory "${(0, path_1.relative)(process.cwd(), migrationsDir)}" does not exist!`);
        }
        const allEnvironments = await this.client.environments.list();
        const primaryEnv = allEnvironments.find((env) => env.meta.primary);
        const sourceEnv = sourceEnvId
            ? await this.client.environments.find(sourceEnvId)
            : primaryEnv;
        if (!sourceEnv) {
            this.error(`You have no permissions to access the "${sourceEnvId ? `"${sourceEnvId}"` : 'primary'}" environment!`);
        }
        let destinationEnvId = inPlace
            ? sourceEnv.id
            : rawDestinationEnvId || `${sourceEnv.id}-post-migrations`;
        this.log(`Migrations will be run in "${destinationEnvId}" sandbox environment`);
        if (inPlace) {
            if (primaryEnv && primaryEnv.id === destinationEnvId) {
                this.error('Running migrations on primary environment is not allowed!');
            }
        }
        else {
            destinationEnvId = await this.forkEnvironment(sourceEnv, destinationEnvId, allEnvironments, dryRun);
        }
        const envClient = this.buildClient({ environment: destinationEnvId });
        const migrationModel = await this.upsertMigrationModel(envClient, migrationsModelApiKey, dryRun);
        const migrationScriptsToRun = await this.migrationScriptsToRun(migrationModel, envClient, migrationsDir);
        const someMigrationScriptRequiresLegacyClient = migrationScriptsToRun.some((s) => s.legacy);
        let legacyEnvClient = null;
        if (someMigrationScriptRequiresLegacyClient) {
            const config = this.buildBaseClientInitializationOptions();
            try {
                // eslint-disable-next-line node/no-missing-require, unicorn/prefer-module
                const { SiteClient } = require('datocms-client');
                legacyEnvClient = new SiteClient(config.apiToken, {
                    environment: destinationEnvId,
                });
            }
            catch {
                this.error('Detected some migrations that require legacy client', {
                    suggestions: ['Please add the "datocms-client" NPM package'],
                });
            }
        }
        for (const migrationScript of migrationScriptsToRun) {
            // eslint-disable-next-line no-await-in-loop
            await this.runMigrationScript(migrationScript, envClient, legacyEnvClient, dryRun, migrationModel, migrationsDir);
        }
        this.log(migrationScriptsToRun.length === 0
            ? `No new migration scripts to run, skipping operation`
            : `Successfully run ${migrationScriptsToRun.length} migration scripts`);
        return {
            environmentId: destinationEnvId,
            runMigrationScripts: migrationScriptsToRun.map((s) => s.path),
        };
    }
    async runMigrationScript(script, envClient, legacyEnvClient, dryRun, migrationModel, migrationsDir) {
        const relativePath = (0, path_1.relative)(migrationsDir, script.path);
        this.startSpinner(`Running migration "${relativePath}"`);
        if (!dryRun) {
            if (script.filename.endsWith('.ts') &&
                !this.registeredTsNode &&
                process.env.NODE_ENV !== 'development') {
                this.registeredTsNode = true;
                const project = await (0, find_nearest_file_1.findNearestFile)('tsconfig.json');
                (0, ts_node_1.register)({ project });
            }
            // eslint-disable-next-line unicorn/prefer-module
            const exportedThing = require(script.path);
            const migration = typeof exportedThing === 'function'
                ? exportedThing
                : 'default' in exportedThing &&
                    typeof exportedThing.default === 'function'
                    ? exportedThing.default
                    : undefined;
            if (!migration) {
                this.error('The script does not export a valid migration function');
            }
            try {
                await migration(script.legacy ? legacyEnvClient : envClient);
            }
            catch (e) {
                this.stopSpinner('failed!');
                if (e instanceof Error) {
                    this.log();
                    this.log('----');
                    this.log(e.stack);
                    this.log('----');
                    this.log();
                }
                this.error(`Migration "${relativePath}" failed`);
            }
        }
        this.stopSpinner();
        if (!dryRun && migrationModel) {
            await envClient.items.create({
                item_type: migrationModel,
                name: relativePath,
            });
        }
    }
    async migrationScriptsToRun(migrationModel, envClient, migrationsDir) {
        const alreadyRunMigrations = migrationModel
            ? await this.fetchAlreadyRunMigrationScripts(envClient, migrationModel)
            : [];
        const allMigrationScripts = (await (0, promises_1.readdir)(migrationsDir))
            .filter((file) => file.match(MIGRATION_FILE_REGEXP))
            .map((file) => ({
            filename: file,
            path: (0, path_1.join)(migrationsDir, file),
            legacy: false,
        }));
        let allLegacyMigrationScripts = [];
        try {
            const legacyMigrationsDir = (0, path_1.join)(migrationsDir, 'legacyClient');
            await (0, promises_1.access)(legacyMigrationsDir);
            allLegacyMigrationScripts = (await (0, promises_1.readdir)(legacyMigrationsDir))
                .filter((file) => file.match(MIGRATION_FILE_REGEXP))
                .map((file) => ({
                filename: file,
                path: (0, path_1.join)(legacyMigrationsDir, file),
                legacy: true,
            }));
        }
        catch { }
        return [...allMigrationScripts, ...allLegacyMigrationScripts]
            .sort((a, b) => a.filename.localeCompare(b.filename))
            .filter((script) => !alreadyRunMigrations.includes(script.filename));
    }
    async forkEnvironment(sourceEnv, destinationEnvId, allEnvironments, dryRun) {
        this.startSpinner(`Creating a fork of "${sourceEnv.id}" environment called "${destinationEnvId}"`);
        const existingEnvironment = allEnvironments.find((env) => env.id === destinationEnvId);
        if (existingEnvironment) {
            this.error(`Environment "${destinationEnvId}" already exists!`, {
                suggestions: [
                    `To execute the migrations inside the existing environment, run "${this.config.bin} migrations:run --source=${destinationEnvId} --in-place"`,
                    `To delete the environment, run "${this.config.bin} environments:destroy ${destinationEnvId}"`,
                ],
            });
        }
        if (!dryRun) {
            await this.client.environments.fork(sourceEnv.id, {
                id: destinationEnvId,
            });
        }
        this.stopSpinner();
        return dryRun ? sourceEnv.id : destinationEnvId;
    }
    async fetchAlreadyRunMigrationScripts(client, model) {
        const migrationScripts = [];
        for await (const item of client.items.listPagedIterator({
            filter: { type: model.id },
        })) {
            migrationScripts.push(item.name);
        }
        return migrationScripts;
    }
    async upsertMigrationModel(client, migrationModelApiKey, dryRun) {
        try {
            return await client.itemTypes.find(migrationModelApiKey);
        }
        catch (e) {
            if (e instanceof cma_client_node_1.ApiError && e.response.status === 404) {
                this.startSpinner(`Creating "${migrationModelApiKey}" model`);
                let migrationItemType = null;
                if (!dryRun) {
                    migrationItemType = await this.createMigrationModel(client, migrationModelApiKey);
                }
                this.stopSpinner();
                return migrationItemType;
            }
            throw e;
        }
    }
    async createMigrationModel(client, migrationModelApiKey) {
        const model = await client.itemTypes.create({
            name: 'Schema migration',
            api_key: migrationModelApiKey,
            draft_mode_active: false,
        });
        await client.fields.create(model.id, {
            label: 'Migration file name',
            api_key: 'name',
            field_type: 'string',
            validators: {
                required: {},
            },
        });
        return model;
    }
}
exports.default = Command;
Command.description = 'Run migration scripts that have not run yet';
Command.flags = {
    ...cli_utils_1.CmaClientCommand.flags,
    source: cli_utils_1.oclif.Flags.string({
        description: 'Forces the creation of a TypeScript migration file',
    }),
    destination: cli_utils_1.oclif.Flags.string({
        description: 'Forces the creation of a JavaScript migration file',
        exclusive: ['in-place'],
    }),
    'in-place': cli_utils_1.oclif.Flags.boolean({
        description: 'Forces the creation of a JavaScript migration file',
        exclusive: ['destination'],
    }),
    'dry-run': cli_utils_1.oclif.Flags.boolean({
        description: 'Forces the creation of a JavaScript migration file',
    }),
    'migrations-dir': cli_utils_1.oclif.Flags.string({
        description: 'Directory where script migrations are stored',
    }),
    'migrations-model': cli_utils_1.oclif.Flags.string({
        description: 'API key of the DatoCMS model used to store migration data',
    }),
};
